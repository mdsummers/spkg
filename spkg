#!/bin/bash
set -e

SOURCE_DIR=`rpm -E '%_sourcedir'`
SRPM_DIR=`rpm -E '%_srcrpmdir'`

[ -d "$SOURCE_DIR" ] || rpmdev-setuptree 2>/dev/null || :

function _title () {
  local color=`tput bold; tput setaf 4`
  local reset=`tput sgr0`
  local caller=`caller 0 | awk '{print $2}'`
  echo "${color}==== ${caller^^}${@:+ - }$@${reset}" >&2
}

function init () {
  _title "Setup a build directory from given srpm"
  local srpm="$1"
  if [ ! -f "$srpm" ]; then
    echo "Given srpm does not exist ($1)" >&2
    return 1
  fi

  # check it is an srpm
  if ! rpm -q --qf "%|SOURCERPM?{no}:{yes}|\n" -p "$srpm" 2>&1 | \
    grep -q yes; then
    echo "Given file is not an srpm" >&2
    return 1
  fi

  if ! type rpmdev-extract >/dev/null 2>&1; then
    echo "rpmdev-extract is not installed, aborting." >&2
    return 1
  fi

  local temp_dir=`mktemp -d -t spkg.XXXX`
  rpmdev-extract -C "$temp_dir" "$srpm"
  # check count of extracted dirs
  if [ `ls "${temp_dir}" | wc -l` -ne 1 ]; then
    echo "Expected one file (dir) under temp dir (${temp_dir})" >&2
    return 1
  fi
  # check it is actually a dir
  local dir1 dir2
  dir1=`echo "$temp_dir"/*`
  if ! [ -d "$dir1" ]; then
    echo "${dir1} is not a directory" >&2
    return 1
  fi
  # remove temp dir prefix
  dir2=`basename "$dir1"`
  if [ -d "$dir2" ]; then
    echo "Directory already exists for this srpm (${dir2}), aborting" >&2
    return 1
  fi

  mkdir -- "${dir2}"
  if [ `ls "${dir1}"/*.spec | wc -l` -ne 1 ]; then
    echo "More than one spec file in the srpm!" >&2
    return 1
  fi
  mv "${dir1}"/*.spec "${dir2}"/

  mkdir -- "${dir2}/sources"
  if ! type spectool >/dev/null 2>&1; then
    echo "spectool is not installed, aborting" >&2
    return 1
  fi

  echo "Moving non-remote sources into place"
  local sfiles #source files
  sfiles=`spectool -l "$dir2"/*.spec | cut -d ' ' -f 2- | egrep -v '(https?|ftp)://'`
  local oldifs="$IFS"
  IFS=$'\n'
  for sfile in $sfiles; do
    mv -v -- "${dir1}/${sfile}" "${dir2}/sources/"
  done
  IFS="$oldifs"

  echo "Moving remote sources into SOURCE dir"
  mv -v -- "$dir1"/* "$SOURCE_DIR"/ || :
  rmdir "$dir1" "$temp_dir"
  cd "${dir2}"
  echo "Triggering sums"
  sums
  echo "New build directory under ${dir2}"
}

function _print_last_srpm () {
  local srpm=`ls -1t "$SRPM_DIR" | head -1`
  echo "${SRPM_DIR}/${srpm}"
}

function _build_srpm () {
  local spec="$1"
  rpmbuild -bs --nodeps "$spec"
}

function prep () {
  _title "Fetch remote sources and build an srpm"
  local spec=`find . -maxdepth 1 -name "*.spec" | head -1`
  spectool -g -R "$spec"
  rsync -a sources/ "$SOURCE_DIR"/
  _build_srpm "$spec"
  sums
}

function deps () {
  _title "Ensure all BuildRequires are installed"
  local spec=`find . -maxdepth 1 -name "*.spec" | head -1`
  if ! _build_srpm "$spec" >/dev/null 2>&1; then
    echo "Cannot build srpm, triggering prep" >&2
    prep
  fi
  local srpm
  srpm=`_print_last_srpm`
  sudo yum-builddep "$srpm" || :
}

function build () {
  _title "Build rpm(s)"
  local spec=`find . -maxdepth 1 -name "*.spec" | head -1`
  if ! _build_srpm "$spec" >/dev/null 2>&1; then
    echo "Cannot build srpm, triggering prep" >&2
    prep
  fi
  _verify_sums
  rpmbuild -bb "$spec"
}

function _print_file_checksums () {
  local file="$1"
  if ! [ -f "$file" ]; then
    echo "Usage: $0 path/to/file" >&2
    return 1
  fi

  local sumalg sum
  for sumalg in md5sum sha1sum sha256sum; do
    sum=`$sumalg "$file" | awk '{ print $1 }'`
    printf "%-10s %s\n" "$sumalg" "$sum"
  done
}

function _verify_sums () {
  if ! [ -f checksums ]; then
    echo "No checksums file, cannot verify sums" >&2
    return
  fi

  local fsum fname retval=0
  while read -r fsum fname; do
    echo "Checking $fname..."
    if ! [ -f "${SOURCE_DIR}/${fname}" ]; then
      echo "$fname is missing" >&2
      retval=$((retval+1))
      continue
    fi

    local csum # freshly computed sum
    csum=`sha256sum "${SOURCE_DIR}/${fname}" | awk '{print $1}'`
    if [ "$csum" != "$fsum" ]; then
      echo "Expected $fsum, computed $csum" >&2
      retval=$((retval+1))
    fi
  done < checksums
  return $retval
}

function _promptYn () {
  local resp
  read -p "$1 [Ynq]: " resp < /dev/tty
  case resp in
    n)
      return 1
      ;;
    q)
      echo "Exiting"
      exit 0
      ;;
    Y|*)
      return 0
      ;;
  esac
}

function sums () {
  _title "Populate or refresh the checksums file"
  local spec=`find . -maxdepth 1 -name "*.spec" | head -1`
  [ -f checksums ] || touch checksums
  checksums_new=`mktemp -t checksums.XXXX`
  trap "rm -f ${checksums_new}" EXIT
  local sname sfile furl fsum fname csum
  while read -r sname furl; do # spectool
    echo "$furl =>"
    sfile="$SOURCE_DIR"/`basename "$furl"`
    if ! [ -f "$sfile" ]; then
      echo "Have not downloaded ${furl} - skipping" >&2
      continue
    fi
    # compute a sum for comparisons
    csum=`sha256sum "$sfile" | awk '{print $1}'`
    # does it exist in the checksums file?
    local in_checksums=0
    while read -r fsum fname; do
      if [ "$fname" = "`basename "$furl"`" ]; then
        if [ "$fsum" = "$csum" ]; then
          echo "Checksum already exists." >&2
          echo "$fsum $fname" > "$checksums_new"
          in_checksums=1
        else
          echo "Existing checksum does not match, ignoring" >&2
        fi
      fi
    done < checksums

    if [ $in_checksums -ne 1 ]; then
      echo "Is not in the checksums file"
      _print_file_checksums "$sfile"
      if _promptYn "Add sum to file?"; then
        echo "${csum} `basename $furl`" >> "$checksums_new"
      fi
    fi
    echo
  done < <(spectool -l "$spec" | egrep '(https?|ftp)://')

  echo "Checking for changes in checksums"
  if ! diff -u checksums "$checksums_new"; then
    echo
    _promptYn "Update checksums file?" && cp -f "$checksums_new" checksums || :
  else
    echo "No change in checksums."
  fi
  # cleanup
  trap - EXIT
  rm -f "$checksums_new"
}

function process_args () {
  local cmd="$1"
  shift

  # getopts loop for any $0 options
  [ "$cmd" = spkg ] && while getopts ':' flag; do
    echo "$OPTARG"
    shift
  done

  case "$cmd" in
    spkg)
      process_args "$@"
      ;;
    init|prep|deps|build|sums)
      $cmd "$@"
      ;;
    *)
      usage
      return 1
      ;;
  esac
}

process_args `basename $0` "$@"
